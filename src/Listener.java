import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.util.ArrayList;

/**
 * A convenience class that listens for key, mouse, mouse motion, and mouse wheel events and passes them on to the main class.
 * It listens by implementing interfaces provided in java.awt.event.
 * 
 * @author Dominic
 */
public class Listener implements KeyListener, MouseMotionListener, MouseListener, MouseWheelListener
{
	ArrayList<RollOver> rollOvers;
	
	boolean minusHeld = false;
	boolean plusHeld = false;
	boolean rightHeld = false;
	boolean leftHeld = false;
	boolean upHeld = false;
	boolean downHeld = false;
	boolean mousePressed = false;
	boolean mousePressedInPane = false;
	boolean mousePressedInPaneDots = false;
	boolean mousePressedInPaneSlider = false;
	boolean mousePressedInOpBar = false;
	boolean mousePressedInPatternSelection = false;
	
	Information info;
	
	Point mouseLocation;
	Point mousePressedLocation;
	
	/**
	 * Creates a new Listener with the given Information generated by the main class.
	 * 
	 * @param main - the main class
	 */
	public Listener(Information info)
	{
		this.info = info;
		mouseLocation = new Point();
		mousePressedLocation = new Point();
		rollOvers = new ArrayList<RollOver>();
	}
	
	/**
	 * Invoked when a key is pressed.
	 */
	public void keyPressed(KeyEvent event)
	{
		if (event.getKeyCode() == KeyEvent.VK_ESCAPE)
		{
			System.exit(0);
		}
		else if (event.getKeyCode() == KeyEvent.VK_MINUS)
		{
			minusHeld = true;
		}
		else if (event.getKeyCode() == KeyEvent.VK_EQUALS)
		{
			plusHeld = true;
		}
		else if (event.getKeyCode() == KeyEvent.VK_RIGHT)
		{
			rightHeld = true;
		}
		else if (event.getKeyCode() == KeyEvent.VK_LEFT)
		{
			leftHeld = true;
		}
		else if (event.getKeyCode() == KeyEvent.VK_UP)
		{
			upHeld = true;
		}
		else if (event.getKeyCode() == KeyEvent.VK_DOWN)
		{
			downHeld = true;
		}
		else if (event.getKeyCode() == KeyEvent.VK_P)
		{
			info.pane.paused = !info.pane.paused;
			rollOvers.add(new RollOver(info, info.pane.playBounds, false));
			startLastRollOver();
		}
		else if (event.getKeyCode() == KeyEvent.VK_N)
		{
			info.map.update();
			rollOvers.add(new RollOver(info, info.pane.nextBounds, false));
			startLastRollOver();
		}
		else if (event.getKeyCode() == KeyEvent.VK_C && event.isShiftDown())
		{
			info.map.clear();
			rollOvers.add(new RollOver(info, info.pane.broomBounds, false));
			startLastRollOver();
		}
		event.consume();
	}

	/**
	 * Invoked when a key is released.
	 */
	public void keyReleased(KeyEvent event) 
	{
		if (event.getKeyCode() == KeyEvent.VK_MINUS)
		{
			minusHeld = false;
		}
		else if (event.getKeyCode() == KeyEvent.VK_EQUALS)
		{
			plusHeld = false;
		}
		else if (event.getKeyCode() == KeyEvent.VK_RIGHT)
		{
			rightHeld = false;
		}
		else if (event.getKeyCode() == KeyEvent.VK_LEFT)
		{
			leftHeld = false;
		}
		else if (event.getKeyCode() == KeyEvent.VK_UP)
		{
			upHeld = false;
		}
		else if (event.getKeyCode() == KeyEvent.VK_DOWN)
		{
			downHeld = false;
		}
		event.consume();
	}
	
	/**
	 * Invoked when the mouse is pressed down.
	 */
	public void mousePressed(MouseEvent event) 
	{
		mousePressedLocation = new Point(event.getX(), event.getY());
		mousePressedInPane = false;
		mousePressedInPane = info.pane.mousePressed(event);
		mousePressedInPaneDots = info.pane.dotsBounds.contains(mousePressedLocation);
		mousePressedInPaneSlider = info.pane.speedBar.sliderBounds.contains(mousePressedLocation);
		mousePressedInOpBar = info.opBar.mousePressed(event);
		mousePressedInPatternSelection = info.pane.selector.mousePressed(event);
		mousePressed = true;
		if (mousePressedInPaneDots)
		{
			info.pane.xShift = mousePressedLocation.x - info.pane.x;
			info.pane.yShift = mousePressedLocation.y - info.pane.y;
		}
		else if (info.pane.selector.arrowBounds.contains(mousePressedLocation))
		{
			info.pane.selector.visible = !info.pane.selector.visible;
		}
		else if (!mousePressedInPane && !mousePressedInOpBar && !mousePressedInPatternSelection)
		{
			info.window.mousePressed(event);
		}
		event.consume();
	}
	
	/**
	 * Invoked when the mouse is moved.
	 */
	public void mouseMoved(MouseEvent event)
	{
		mouseLocation.x = event.getX();
		mouseLocation.y = event.getY();
		event.consume();
	}
	
	/**
	 * Invoked when the mouse is held and moved.
	 */
	public void mouseDragged(MouseEvent event) 
	{
		mouseLocation.x = event.getX();
		mouseLocation.y = event.getY();
		if (mousePressedInPaneDots)
		{
			int prevx = info.pane.x;
			int prevy = info.pane.y;
			info.pane.x = mouseLocation.x - info.pane.xShift;
			info.pane.y = mouseLocation.y - info.pane.yShift;
			info.pane.setRectangles();
			info.pane.beingDragged = true;
			if (info.pane.rect.intersects(info.opBar.bounds))
			{
				info.pane.x = prevx;
				info.pane.y = prevy;
				info.pane.setRectangles();
			}
			if (info.pane.x < 0)
			{
				info.pane.x = 0;
				info.pane.setRectangles();
			}
			if (info.pane.y < 0)
			{
				info.pane.y = 0;
				info.pane.setRectangles();
			}
			if (info.pane.x + info.pane.width > info.screen.width)
			{
				info.pane.x = info.screen.width - info.pane.width;
				info.pane.setRectangles();
			}
			if (info.pane.y + info.pane.height > info.screen.height)
			{
				info.pane.y = info.screen.height - info.pane.height;
				info.pane.setRectangles();
			}
		}
		else if (mousePressedInPaneSlider)
		{
			info.pane.speedBar.setSliderBounds(Math.min(Math.max(mouseLocation.x, info.pane.speedBar.minSliderX + info.pane.speedBar.bounds.x),
					info.pane.speedBar.maxSliderX + info.pane.speedBar.bounds.x), false);
		}
		else if (!mousePressedInPatternSelection)
		{
			info.window.mouseDragged();
		}
		event.consume();
	}
	
	/**
	 * Unused: Invoked when a key is pressed and released (high-level).
	 */
	public void keyTyped(KeyEvent event) 
	{
		event.consume();
	}

	/**
	 * Unused: Invoked when the mouse is pressed and released (high-level).
	 */
	public void mouseClicked(MouseEvent event) 
	{
		event.consume();
	}

	/**
	 * Unused: Invoked when the mouse enters a component.
	 */
	public void mouseEntered(MouseEvent event) 
	{
		event.consume();
	}

	/**
	 * Unused: Invoked when the mouse exits a component.
	 */
	public void mouseExited(MouseEvent event) 
	{
		event.consume();
	}

	/**
	 * Unused: Invoked when the mouse is released.
	 */
	public void mouseReleased(MouseEvent event) 
	{
		mousePressed = false;
		mousePressedInPane = false;
		mousePressedInPaneDots = false;
		mousePressedInOpBar = false;
		info.pane.beingDragged = false;
		event.consume();
	}

	/**
	 * Unused: Invoked when the mouse wheel is rotated.
	 */
	public void mouseWheelMoved(MouseWheelEvent event) 
	{
		event.consume();
	}
	
	public void startLastRollOver()
	{
		(new Thread(rollOvers.get(rollOvers.size() - 1))).start();
	}
}
